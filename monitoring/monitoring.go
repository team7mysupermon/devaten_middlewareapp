package monitoring

//see prometheus config docs:
// https://prometheus.io/docs/guides/go-application/

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/team7mysupermon/devaten_middlewareapp/storage"
	"github.com/tidwall/gjson"
)

var (
	startAutoGenerated storage.StartAutoGenerated
	runAutoGenerated   storage.RunAutoGenerated
	stopAutoGenerated  storage.StopAutoGenerated

	stopmetrics = make(map[string]prometheus.Gauge)

	usecasestopmetrics = make(map[string]interface{})
	stopdetails        []storage.Stop
)

func Monitor() {
	startRegisterMetrics()
	runRegisterMetrics()
	stopRegisterMetrics()

	go http.Handle("/metrics", promhttp.Handler())

	err := http.ListenAndServe(":9091", nil)
	if err != nil {
		log.Fatalln("Failed to serve metrics on port 9091 ")
	}

	log.Fatal(http.ListenAndServe(":9091", nil))

}

func ParseBody(body []byte, action string) {

	fmt.Println(string(body))

	if action == "start" {
		err := json.Unmarshal(body, &startAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}

		startRecordMetrics()
	}

	if action == "run" {
		err := json.Unmarshal(body, &runAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}

		runRecordMetrics()
	}

	if action == "stop" {
		err := json.Unmarshal(body, &stopAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}

		stopRecordMetrics()
	}

}
func CreateStopMetrics(arr []string) {
	scientists := []string{
		"Einstein",
	}
	mfs, err := prometheus.DefaultGatherer.Gather()
	//fmt.Println("data is kkkk",mfs )
	if err != nil {
		panic(err)
	}

	for _, mf := range mfs {
		fmt.Println(mf.GetName())
		scientists = append(scientists, mf.GetName())

	}
	//fmt.Println("data is kkkk", col)
	justString := strings.Join(scientists, " ")
	for x := 0; x < len(arr); x++ {
		stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"] = prometheus.NewGauge(
			prometheus.GaugeOpts{
				Name: "STOP_" + strings.ToUpper(arr[x]) + "_GAUGE",
				Help: "",
			})

		registered := strings.Contains(justString, "STOP_"+strings.ToUpper(arr[x])+"_GAUGE")
		if !registered {

			prometheus.MustRegister(
				prometheus.NewGauge(
					prometheus.GaugeOpts{
						Name: "STOP_" + strings.ToUpper(arr[x]) + "_GAUGE",
						Help: "",
					}))
		}
	}

	// http.HandleFunc("/metrics", func(writer http.ResponseWriter, _ *http.Request) {
	// 	for _, mf := range mfs {
	// 		fmt.Println(mf)
	// 		if mf.Help != nil && *mf.Help == "test histogram bucket" {
	// 			if _, err := expfmt.MetricFamilyToText(writer, mf); err != nil {
	// 				if err != nil {
	// 					panic(err)
	// 				}
	// 			}
	// 		}
	// 	}
	// })
}
func RecordStopMetrics(body []byte) {
	var stopmetrics = GetStopMetricsMap()
	value10 := gjson.Get(string(body), "data").Array()
	for _, v := range value10 {

		for key, val := range v.Map() {
			fmt.Println("ddara", key)
			err := json.Unmarshal([]byte(val.Raw), &stopdetails)
			if err != nil {
				panic(err)
			}
			var stopcolumnsmetrics = make(map[string]float64)
			for x := 0; x < len(stopdetails); x++ {
				stopData := stopdetails[x].ValueObjectList

				for y := 0; y < len(stopData); y++ {
					stopcolumnsmetrics["STOP_"+strings.ToUpper(stopData[y].ColumnName)+"_GAUGE"] = stopData[y].NewValue

				}

			}
			usecasestopmetrics[key] = stopcolumnsmetrics
		}
	}
	for key, element := range usecasestopmetrics {
		fmt.Println("Key:", key, "=>", "Element:", element)
		myMap := element.(map[string]float64)
		for columnname, value := range myMap {
			fmt.Println(columnname, value)
			//columnValue := value.(float64)
			stopmetrics[columnname].Set(value)
		}
	}
	for key, element := range stopmetrics {
		fmt.Println("Key:", key, "=>", "Element:", element)
		//element.Set(22)
	}
}

func GetStopMetricsMap() map[string]prometheus.Gauge {

	stopmetrics["STOP_SQL_PER_SEC_GAUGE"] = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "STOP_SQL_PER_SEC_GAUGE",
			Help: "",
		})
	return stopmetrics
}
