package monitoring

//see prometheus config docs:
// https://prometheus.io/docs/guides/go-application/

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/team7mysupermon/devaten_middlewareapp/storage"
	"github.com/tidwall/gjson"
)

var (
	//startAutoGenerated storage.StartAutoGenerated
	runAutoGenerated storage.RunAutoGenerated
	//	stopAutoGenerated  storage.StopAutoGenerated
	dbinstancemetrics  = make(map[string]*prometheus.GaugeVec)
	stopmetrics        = make(map[string]*prometheus.GaugeVec)
	runmetrics         = make(map[string]*prometheus.GaugeVec)
	databasetype       string
	usecasestopmetrics = make(map[string]interface{})
	stopdetails        []storage.Stop
)

func Monitor() {
	startRegisterMetrics()
	runRegisterMetrics()
	//	stopRegisterMetrics()

	go http.Handle("/metrics", promhttp.Handler())

	err := http.ListenAndServe(":9091", nil)
	if err != nil {
		log.Fatalln("Failed to serve metrics on port 9091 ")
	}

	log.Fatal(http.ListenAndServe(":9091", nil))

}

func ParseBody(body []byte, action string) {
	justString := GetPrometheusRegisteredMetrics()
	fmt.Println(string(body))

	if action == "start" {

		startdataresponse := gjson.Get(string(body), "data.dataSourceList.#.databaseType").Array()

		databasetype = startdataresponse[0].String()
		fmt.Println(databasetype)
		instanceinfo := gjson.Get(string(body), "data.dataSourceList.#.data").Array()
		fmt.Println(instanceinfo[0].Map())
		go func() {
			for key, val := range instanceinfo[0].Map() {
				fmt.Println(key, val)

				dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"] = prometheus.NewGaugeVec(
					prometheus.GaugeOpts{
						Name: "DBINSTANCE_" + strings.ToUpper(key) + "_GAUGE",
						Help: "",
					}, []string{
						// Which user has requested the operation?
						"database",
						// Of what type is the operation?

					},
				)
				registered := strings.Contains(justString, "DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE")
				if !registered {

					prometheus.MustRegister(
						dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"],
					)
				}
				dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype)}).Set(val.Float())
			}
		}()
		// err := json.Unmarshal(body, &startAutoGenerated)
		// if err != nil {
		// 	log.Panicln(err)
		// }

		//startRecordMetrics()
	}

	if action == "run" {
		runinfo := gjson.Get(string(body), "data.runSituationResult.#.data").Array()
		fmt.Println(len(runinfo))

		go func() {
			for _, run := range runinfo {
				for key, val := range run.Map() {
					fmt.Println(key, val)

					runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"] = prometheus.NewGaugeVec(
						prometheus.GaugeOpts{
							Name: "RUN_" + strings.ToUpper(key) + "_GAUGE",
							Help: "",
						}, []string{
							// Which user has requested the operation?
							"database",
							// Of what type is the operation?

						},
					)
					registered := strings.Contains(justString, "RUN_"+strings.ToUpper(key)+"_GAUGE")
					if !registered {

						prometheus.MustRegister(
							runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"],
						)
					}
					runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype)}).Set(val.Float())
				}
			}
		}()

		// err := json.Unmarshal(body, &runAutoGenerated)
		// if err != nil {
		// 	log.Panicln(err)
		// }

		// runRecordMetrics()
	}

}
func CreateStopMetrics(arr []string) {
	justString := GetPrometheusRegisteredMetrics()
	go func() {
		for x := 0; x < len(arr); x++ {

			stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"] = prometheus.NewGaugeVec(
				prometheus.GaugeOpts{
					Name: "STOP_" + strings.ToUpper(arr[x]) + "_GAUGE",
					Help: "",
				}, []string{
					// Which user has requested the operation?
					"database",
					// Of what type is the operation?
					"usecase",
				},
			)
			registered := strings.Contains(justString, "STOP_"+strings.ToUpper(arr[x])+"_GAUGE")
			if !registered {

				prometheus.MustRegister(
					stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"],
				)
			}
		}
	}()

}
func RecordStopMetrics(body []byte) {
	var stopmetrics = GetStopMetricsMap()
	value10 := gjson.Get(string(body), "data").Array()
	for _, v := range value10 {

		for key, val := range v.Map() {
			fmt.Println("ddara", key)
			err := json.Unmarshal([]byte(val.Raw), &stopdetails)
			if err != nil {
				panic(err)
			}
			var stopcolumnsmetrics = make(map[string]float64)
			for x := 0; x < len(stopdetails); x++ {
				stopData := stopdetails[x].ValueObjectList

				for y := 0; y < len(stopData); y++ {
					stopcolumnsmetrics["STOP_"+strings.ToUpper(stopData[y].ColumnName)+"_GAUGE"] = stopData[y].NewValue

				}

			}
			usecasestopmetrics[key] = stopcolumnsmetrics
		}
	}
	for key, element := range usecasestopmetrics {
		fmt.Println("Key:", key, "=>", "Element:", element)
		myMap := element.(map[string]float64)
		for columnname, value := range myMap {
			fmt.Println(columnname, value)
			//columnValue := value.(float64)
			fmt.Println(stopmetrics[columnname])
			var datav = columnname
			var valuedata = value
			go func() {
				for {

					stopmetrics[datav].With(prometheus.Labels{"database": strings.ToUpper(databasetype), "usecase": key}).Set(valuedata)
					time.Sleep(5 * time.Second)
				}
			}()

		}
	}

}

func GetStopMetricsMap() map[string]*prometheus.GaugeVec {

	stopmetrics["STOP_SQL_PER_SEC_GAUGE"] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "STOP_SQL_PER_SEC_GAUGE",
			Help: "",
		}, []string{
			// Which user has requested the operation?
			"databse",
			// Of what type is the operation?
			"usecase",
		},
	)
	return stopmetrics
}
func GetPrometheusRegisteredMetrics() string {
	scientists := []string{
		"Einstein",
	}
	mfs, err := prometheus.DefaultGatherer.Gather()
	//fmt.Println("data is kkkk",mfs )
	if err != nil {
		panic(err)
	}

	for _, mf := range mfs {
		fmt.Println(mf.GetName())
		scientists = append(scientists, mf.GetName())

	}
	//fmt.Println("data is kkkk", col)
	justString := strings.Join(scientists, " ")

	return justString
}
