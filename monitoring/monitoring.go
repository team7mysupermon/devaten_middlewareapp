package monitoring

//see prometheus config docs:
// https://prometheus.io/docs/guides/go-application/

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/team7mysupermon/devaten_middlewareapp/storage"
	"github.com/tidwall/gjson"
)

var (
	//startAutoGenerated storage.StartAutoGenerated
	//runAutoGenerated storage.RunAutoGenerated
	//	stopAutoGenerated  storage.StopAutoGenerated
	dbinstancemetrics    = make(map[string]*prometheus.GaugeVec)
	stopmetrics          = make(map[string]*prometheus.GaugeVec)
	runmetrics           = make(map[string]*prometheus.GaugeVec)
	mostexecutedmetrics  = make(map[string]*prometheus.GaugeVec)
	worstexecutedmetrics = make(map[string]*prometheus.GaugeVec)

	databasetype       string
	starttimestamp     string
	usecasestopmetrics = make(map[string]interface{})
	stopdetails        []storage.Stop
	reportdata         []storage.ReportData
)

func Monitor() {
	//startRegisterMetrics()
	//runRegisterMetrics()
	//	stopRegisterMetrics()

	go http.Handle("/metrics", promhttp.Handler())

	err := http.ListenAndServe(":9091", nil)
	if err != nil {
		log.Fatalln("Failed to serve metrics on port 9091 ")
	}

	log.Fatal(http.ListenAndServe(":9091", nil))

}

func ParseBody(body []byte, action string) {
	justString := GetPrometheusRegisteredMetrics()
	//fmt.Println(string(body))

	if action == "start" {

		startdataresponse := gjson.Get(string(body), "data.dataSourceList.#.databaseType").Array()

		databasetype = startdataresponse[0].String()
		//fmt.Println(databasetype)
		instanceinfo := gjson.Get(string(body), "data.dataSourceList.#.data").Array()
		//fmt.Println(instanceinfo[0].Map())
		go func() {
			for key, val := range instanceinfo[0].Map() {
				fmt.Println(key, val)

				dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"] = prometheus.NewGaugeVec(
					prometheus.GaugeOpts{
						Name: "DBINSTANCE_" + strings.ToUpper(key) + "_GAUGE",
						Help: "",
					}, []string{
						// Which user has requested the operation?
						"database",
						// Of what type is the operation?

					},
				)
				registered := strings.Contains(justString, "DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE")
				if !registered {

					prometheus.MustRegister(
						dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"],
					)
				}
				dbinstancemetrics["DBINSTANCE_"+strings.ToUpper(key)+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype)}).Set(val.Float())
			}
		}()
		// err := json.Unmarshal(body, &startAutoGenerated)
		// if err != nil {
		// 	log.Panicln(err)
		// }

		//startRecordMetrics()
	}

	if action == "run" {
		runinfo := gjson.Get(string(body), "data.runSituationResult.#.data").Array()
		//fmt.Println(len(runinfo))

		go func() {
			for _, run := range runinfo {
				for key, val := range run.Map() {
					//fmt.Println(key, val)

					runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"] = prometheus.NewGaugeVec(
						prometheus.GaugeOpts{
							Name: "RUN_" + strings.ToUpper(key) + "_GAUGE",
							Help: "",
						}, []string{
							// Which user has requested the operation?
							"database",
							// Of what type is the operation?

						},
					)
					registered := strings.Contains(justString, "RUN_"+strings.ToUpper(key)+"_GAUGE")
					if !registered {

						prometheus.MustRegister(
							runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"],
						)
					}
					runmetrics["RUN_"+strings.ToUpper(key)+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype)}).Set(val.Float())
				}
			}
		}()

		// err := json.Unmarshal(body, &runAutoGenerated)
		// if err != nil {
		// 	log.Panicln(err)
		// }

		// runRecordMetrics()
	}

}
func CreateStopMetrics(arr []string) {
	justString := GetPrometheusRegisteredMetrics()
	//fmt.Println(justString)
	go func() {
		for x := 0; x < len(arr); x++ {

			stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"] = prometheus.NewGaugeVec(
				prometheus.GaugeOpts{
					Name: "STOP_" + strings.ToUpper(arr[x]) + "_GAUGE",
					Help: "",
				}, []string{
					// Which user has requested the operation?
					"database",
					// Of what type is the operation?
					"usecase",

					"starttimestamp",
				},
			)
			registered := strings.Contains(justString, "STOP_"+strings.ToUpper(arr[x])+"_GAUGE")
			//fmt.Println(registered)
			//fmt.Println("STOP_" + strings.ToUpper(arr[x]) + "_GAUGE")
			if !registered {

				prometheus.MustRegister(
					stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"],
				)
				stopmetrics["STOP_"+strings.ToUpper(arr[x])+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype), "usecase": "DEMO", "starttimestamp": "starttimestamp"}).Set(0)
			}
		}
	}()

}
func RecordStopMetrics(body []byte) {
	var stopmetrics = GetStopMetricsMap()
	value10 := gjson.Get(string(body), "data").Array()
	for _, v := range value10 {

		for key, val := range v.Map() {
			//fmt.Println("ddara", key)
			err := json.Unmarshal([]byte(val.Raw), &stopdetails)
			starttimestamp = stopdetails[0].Starttimestamp
			//	fmt.Println(starttimestamp)
			if err != nil {
				panic(err)
			}
			var stopcolumnsmetrics = make(map[string]float64)
			for x := 0; x < len(stopdetails); x++ {
				stopData := stopdetails[x].ValueObjectList

				for y := 0; y < len(stopData); y++ {
					stopcolumnsmetrics["STOP_"+strings.ToUpper(stopData[y].ColumnName)+"_GAUGE"] = stopData[y].NewValue

				}

			}
			usecasestopmetrics[key] = stopcolumnsmetrics
		}
	}
	for key, element := range usecasestopmetrics {
		//fmt.Println("Key:", key, "=>", "Element:", element)
		myMap := element.(map[string]float64)
		for columnname, value := range myMap {
			//fmt.Println(columnname, value)
			//columnValue := value.(float64)
			//fmt.Println(stopmetrics[columnname])
			var datav = columnname
			var valuedata = value
			go func() {
				for {

					stopmetrics[datav].With(prometheus.Labels{"database": strings.ToUpper(databasetype), "usecase": key, "starttimestamp": starttimestamp}).Set(valuedata)
					time.Sleep(5 * time.Second)
				}
			}()

		}
	}

}

func GetStopMetricsMap() map[string]*prometheus.GaugeVec {

	stopmetrics["STOP_SQL_PER_SEC_GAUGE"] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "STOP_SQL_PER_SEC_GAUGE",
			Help: "",
		}, []string{
			// Which user has requested the operation?
			"databse",
			// Of what type is the operation?
			"usecase",
		},
	)
	return stopmetrics
}
func GetPrometheusRegisteredMetrics() string {
	scientists := []string{
		"Einstein",
	}
	mfs, err := prometheus.DefaultGatherer.Gather()
	//fmt.Println("data is kkkk",mfs )
	if err != nil {
		panic(err)
	}

	for _, mf := range mfs {
		//fmt.Println(mf.GetName())
		scientists = append(scientists, mf.GetName())

	}
	//fmt.Println("data is kkkk", col)
	justString := strings.Join(scientists, " ")
	//fmt.Println(justString)

	return justString
}
func RecordReport(body []byte) {
	fmt.Println("this is in report file")
	report := gjson.Get(string(body), "list")

	//fmt.Println(report)
	//for _, rep := range report {

	err := json.Unmarshal([]byte(report.Raw), &reportdata)
	if err != nil {
		panic(err)
	}
	for x := 0; x < len(reportdata); x++ {
		mostExecuteddata := reportdata[x].MostExecuted
		starttimestamp := reportdata[x].Starttimestamp

		for y := 0; y < len(mostExecuteddata); y++ {
			queryid := mostExecuteddata[y].QueryId
			usecaseIdentifier := mostExecuteddata[y].UsecaseIdentifier

			fmt.Println(mostExecuteddata[y].Colvalues)
			res := strings.Split(mostExecuteddata[y].Colvalues, ",")

			for j := 0; j < len(res); j++ {
				medata := strings.Split(res[j], "|")
				fmt.Println(medata[0], medata[1])
				//mecolumn := medata[0]
				//mevalue := medata[1]
				mostexecutedmetrics["MOSTEXECUTE_"+strings.ToUpper(medata[0])+"_GAUGE"] = prometheus.NewGaugeVec(
					prometheus.GaugeOpts{
						Name: "MOSTEXECUTE_" + strings.ToUpper(medata[0]) + "_GAUGE",
						Help: "",
					}, []string{
						// Which user has requested the operation?
						"database",
						"usecase",
						"queryid",
						"startimestamp",
						// Of what type is the operation?

					},
				)
				justString := GetPrometheusRegisteredMetrics()

				registered := strings.Contains(justString, "MOSTEXECUTE_"+strings.ToUpper(medata[0])+"_GAUGE")
				if !registered {

					prometheus.MustRegister(
						mostexecutedmetrics["MOSTEXECUTE_"+strings.ToUpper(medata[0])+"_GAUGE"],
					)
				}

				if s, err := strconv.ParseFloat(medata[1], 64); err == nil {
					go func() {
						for {
							mostexecutedmetrics["MOSTEXECUTE_"+strings.ToUpper(medata[0])+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype), "usecase": usecaseIdentifier, "queryid": queryid, "startimestamp": starttimestamp}).Set(s)
							time.Sleep(5 * time.Second)
						}
					}()
				}

			}

		}
		wrostExecuteddata := reportdata[x].WrostExecuted
		for i := 0; i < len(wrostExecuteddata); i++ {
			fmt.Println(wrostExecuteddata[i].Colvalues)
			queryid := wrostExecuteddata[i].QueryId
			usecaseIdentifier := wrostExecuteddata[i].UsecaseIdentifier

			res1 := strings.Split(wrostExecuteddata[i].Colvalues, ",")

			for k := 0; k < len(res1); k++ {
				wedata := strings.Split(res1[i], "|")
				fmt.Println(wedata[0], wedata[1])
				//wecolumn := wedata[0]
				//wevalue := wedata[1]
				worstexecutedmetrics["WROSTEXECUTE_"+strings.ToUpper(wedata[0])+"_GAUGE"] = prometheus.NewGaugeVec(
					prometheus.GaugeOpts{
						Name: "WROSTEXECUTE_" + strings.ToUpper(wedata[0]) + "_GAUGE",
						Help: "",
					}, []string{
						// Which user has requested the operation?
						"database",
						"usecase",
						"queryid",
						"startimestamp",
						// Of what type is the operation?

					},
				)
				justString := GetPrometheusRegisteredMetrics()

				registered := strings.Contains(justString, "WROSTEXECUTE_"+strings.ToUpper(wedata[0])+"_GAUGE")
				if !registered {

					prometheus.MustRegister(
						worstexecutedmetrics["WROSTEXECUTE_"+strings.ToUpper(wedata[0])+"_GAUGE"],
					)
				}

				if s, err := strconv.ParseFloat(wedata[1], 64); err == nil {
					go func() {
						for {
							worstexecutedmetrics["WROSTEXECUTE_"+strings.ToUpper(wedata[0])+"_GAUGE"].With(prometheus.Labels{"database": strings.ToUpper(databasetype), "usecase": usecaseIdentifier, "queryid": queryid, "startimestamp": starttimestamp}).Set(s)
							time.Sleep(5 * time.Second)
						}
					}()
				}

			}

		}
	}

	//}
}
